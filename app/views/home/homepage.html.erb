<html>
	<head>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 50%; height: 50% }
		</style>
	</head>
	<p>HELLO</p>
	<body>
		<script src="/assets/three.min.js"></script>
		<script>
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth/2, window.innerHeight/2 );
			document.body.appendChild( renderer.domElement );

			var geometrys = [];
			var materials = [];
			var cubes = [];
			
			for (i = 0; i < 27; i++)
			{
				//Make 27 cubes of size 0.95 units cubed
				geometrys[i] = new THREE.BoxGeometry( 0.95, 0.95, 0.95 );
				materials[i] = new THREE.MeshBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );
				
			}
			
			for (i = 0; i < 27; i++)
			{
				for (j =0; j < 12; j++)
				{
					//Make the rest of the cube grey, for some reason setting the color of the material to grey made nothing render, so I colored each face grey
					geometrys[i].faces[j].color.setHex(0x777777);
				}
			}
			
			//Front Face
			for (i = 0; i < 9; i++)
			{
				geometrys[i].translate(0,0,1);
				geometrys[i].faces[8].color.setHex(0x00ff00);
				geometrys[i].faces[9].color.setHex(0x00ff00);
			}
			
			//Back Face
			for (i = 18; i < 27; i++)
			{
				geometrys[i].translate(0,0,-1);
				geometrys[i].faces[10].color.setHex(0x0000FF);
				geometrys[i].faces[11].color.setHex(0x0000FF);
			}
			
			//Left Face
			for(i = 0; i < 27; i += 3)
			{
				geometrys[i].translate(-1,0,0);
				geometrys[i].faces[2].color.setHex(0xFFA500);
				geometrys[i].faces[3].color.setHex(0xFFA500);
			}
			
			//Right Face
			for(i = 2; i < 27; i+= 3)
			{
				geometrys[i].translate(1,0,0);
				geometrys[i].faces[0].color.setHex(0xFF0000);
				geometrys[i].faces[1].color.setHex(0xFF0000);
			}
			
			//Up Face
			for(i =0; i < 21; i++)
			{
				if ( i == 3) 
				{
					i = 9;
				}
				if ( i == 12)
				{
					i = 18;
				}
				geometrys[i].translate(0,1,0);
				geometrys[i].faces[4].color.setHex(0xFFFFFF);
				geometrys[i].faces[5].color.setHex(0xFFFFFF);
			}
			
			//Down Face
			for(i =6; i < 27; i++)
			{
				if ( i == 9) 
				{
					i = 15;
				}
				if ( i == 18)
				{
					i = 24;
				}
				geometrys[i].translate(0,-1,0);
				geometrys[i].faces[6].color.setHex(0xFFFF00);
				geometrys[i].faces[7].color.setHex(0xFFFF00);
			}
			
			for (i = 0; i < 27; i++)
			{
				cubes[i] = new THREE.Mesh( geometrys[i], materials[i] );
				scene.add( cubes[i] );
			}
			
			var animating = false;
			var g_notation = "a";
			
			var frontFace = [0,1,2,3,4,5,6,7,8];
			var backFace = [18,19,20,21,22,23,24,25,26];
			var leftFace = [0,3,6,9,12,15,18,21,24];
			var rightFace = [2,5,8,11,14,17,20,23,26];
			var upFace = [0,1,2,9,10,11,18,19,20];
			var downFace = [6,7,8,15,16,17,24,25,26];
			
			var frontRotatedCC = [2,5,8,1,4,7,0,3,6];
			var backRotatedCC = [20,23,26,19,22,25,18,21,24];
			var leftRotatedCC = [18,9,0,21,12,3,24,15,6];
			var rightRotatedCC = [20,11,2,23,14,5,26,17,8];
			var upRotatedCC = [18,9,0,19,10,1,20,11,2];
			var downRotatedCC = [24,15,6,25,16,7,26,17,8];
			
			var faceToRotate = frontFace;
			var rotatedFace = frontRotatedCC;
			var upAxis = new THREE.Vector3(0,1,0);

			camera.position.z = 5;
			camera.position.y = 5;
			camera.position.x = 5;
			camera.lookAt(new THREE.Vector3(0,0,0));
			scene.add(new THREE.AmbientLight(0xffffff)); //added scene lights but dont seem to be doing anything

			var render = function () 
			{
				requestAnimationFrame( render );
				// L and R rotates with cubes[faceToRotate[i]].rotation.x   //L stops now
				// F and B rotates with cubes[faceToRotate[i]].rotation.z  // F stops first move
				// U and D rotates with cubes[faceToRotate[i]].rotation.y  // U stops first move
				if (animating)
				{
					
					if(g_notation == "u" )
					{
						for (i = 0; i < 9; i++)
						{
							cubes[faceToRotate[i]].rotation.y += 0.01
						}
						//Math.PI is too precise for direct comparison, so check a range around PI/2 or 90 degrees (1.570796)
						if (cubes[faceToRotate[0]].rotation.y >= 1.565 && cubes[faceToRotate[0]].rotation.y <= 1.575)
						{
							cubes[faceToRotate[0]].rotation.y = Math.PI /2;
							animating = false;
							reassignCubes();
						}
						//implementing dirty checks to prevent over rotation and current wworks with U
						else if (cubes[faceToRotate[0]].rotation.y >= 1.565 + Math.PI / 2 && cubes[faceToRotate[0]].rotation.y <= 1.575 + Math.PI/2){
							cubes[faceToRotate[0]].rotation.y = Math.PI;
							animating = false;
							reassignCubes();
						}
						else if (cubes[faceToRotate[0]].rotation.y >= 1.565 + Math.PI  && cubes[faceToRotate[0]].rotation.y <= 1.575 + Math.PI){
							cubes[faceToRotate[0]].rotation.y = Math.PI + (Math.PI/2);
							animating = false;
							reassignCubes();
						}
						else if (cubes[faceToRotate[0]].rotation.y >= Math.PI * 2)
						{
							for (i = 0; i < 9; i++)
							{
								cubes[faceToRotate[i]].rotation.y = 0;
							
							}
							animating = false;
							reassignCubes();
						}
					}
					else if(g_notation == "d")
					{
						for (i = 0; i < 9; i++)
						{
							cubes[faceToRotate[i]].rotation.y += 0.01
						}
						//Math.PI is too precise for direct comparison, so check a range around PI/2 or 90 degrees (1.570796)
						if (cubes[faceToRotate[0]].rotation.y >= 1.565 && cubes[faceToRotate[0]].rotation.y <= 1.575)
						{
							cubes[faceToRotate[0]].rotation.y = Math.PI /2;
							animating = false;
							reassignCubes();
						}
						//implementing dirty checks to prevent over rotation and current wworks with U
						else if (cubes[faceToRotate[0]].rotation.y >= 1.565 + Math.PI / 2 && cubes[faceToRotate[0]].rotation.y <= 1.575 + Math.PI/2){
							cubes[faceToRotate[0]].rotation.y = Math.PI;
							animating = false;
							reassignCubes();
						}
						else if (cubes[faceToRotate[0]].rotation.y >= 1.565 + Math.PI  && cubes[faceToRotate[0]].rotation.y <= 1.575 + Math.PI){
							cubes[faceToRotate[0]].rotation.y = Math.PI + (Math.PI/2);
							animating = false;
							reassignCubes();
						}
						else if (cubes[faceToRotate[0]].rotation.y >= Math.PI * 2)
						{
							for (i = 0; i < 9; i++)
							{
								cubes[faceToRotate[i]].rotation.y = 0;
							
							}
							animating = false;
							reassignCubes();
						}
					}
					
					else if(g_notation == "f" )
					{ //f and b for z
						for (i = 0; i < 9; i++)
						{
							cubes[faceToRotate[i]].rotation.z += 0.01
						}
						//Math.PI is too precise for direct comparison, so check a range around PI/2 or 90 degrees (1.570796)
						if (cubes[faceToRotate[0]].rotation.z >= 1.565 && cubes[faceToRotate[0]].rotation.z <= 1.575)
						{
							cubes[faceToRotate[0]].rotation.z = Math.PI /2;
							animating = false;
							reassignCubes();
						}
						//implementing dirty checks to prevent over rotation and current wworks with U
						else if (cubes[faceToRotate[0]].rotation.z >= 1.565 + Math.PI / 2 && cubes[faceToRotate[0]].rotation.z <= 1.575 + Math.PI/2){
							cubes[faceToRotate[0]].rotation.z = Math.PI;
							animating = false;
							reassignCubes();
						}
						else if (cubes[faceToRotate[0]].rotation.z >= 1.565 + Math.PI  && cubes[faceToRotate[0]].rotation.z <= 1.575 + Math.PI){
							cubes[faceToRotate[0]].rotation.z = Math.PI + (Math.PI/2);
							animating = false;
							reassignCubes();
						}
						else if (cubes[faceToRotate[0]].rotation.z >= Math.PI * 2)
						{
							for (i = 0; i < 9; i++)
							{
								cubes[faceToRotate[i]].rotation.z = 0;
							
							}
							animating = false;
							reassignCubes();
						}
					}
					else if(g_notation == "b")
					{
						for (i = 0; i < 9; i++)
						{
							cubes[faceToRotate[i]].rotation.z += 0.01
						}
						//Math.PI is too precise for direct comparison, so check a range around PI/2 or 90 degrees (1.570796)
						if (cubes[faceToRotate[0]].rotation.z >= 1.565 && cubes[faceToRotate[0]].rotation.z <= 1.575)
						{
							cubes[faceToRotate[0]].rotation.z = Math.PI /2;
							animating = false;
							reassignCubes();
						}
						//implementing dirty checks to prevent over rotation and current wworks with U
						else if (cubes[faceToRotate[0]].rotation.z >= 1.565 + Math.PI / 2 && cubes[faceToRotate[0]].rotation.z <= 1.575 + Math.PI/2){
							cubes[faceToRotate[0]].rotation.z = Math.PI;
							animating = false;
							reassignCubes();
						}
						else if (cubes[faceToRotate[0]].rotation.z >= 1.565 + Math.PI  && cubes[faceToRotate[0]].rotation.z <= 1.575 + Math.PI){
							cubes[faceToRotate[0]].rotation.z = Math.PI + (Math.PI/2);
							animating = false;
							reassignCubes();
						}
						else if (cubes[faceToRotate[0]].rotation.z >= Math.PI * 2)
						{
							for (i = 0; i < 9; i++)
							{
								cubes[faceToRotate[i]].rotation.z = 0;
							
							}
							animating = false;
							reassignCubes();
						}
					}
					else if(g_notation == "r"  )
					{ //r and l for x
						for (i = 0; i < 9; i++)
						{
							cubes[faceToRotate[i]].rotation.x += 0.01
						}
						//Math.PI is too precise for direct comparison, so check a range around PI/2 or 90 degrees (1.570796)
						if (cubes[faceToRotate[0]].rotation.x >= 1.565 && cubes[faceToRotate[0]].rotation.x <= 1.575)
						{
							cubes[faceToRotate[0]].rotation.x = Math.PI /2;
							animating = false;
							reassignCubes();
						}
						//implementing dirty checks to prevent over rotation and current wworks with U
						else if (cubes[faceToRotate[0]].rotation.x >= 1.565 + Math.PI / 2 && cubes[faceToRotate[0]].rotation.x <= 1.575 + Math.PI/2){
							cubes[faceToRotate[0]].rotation.x = Math.PI;
							animating = false;
							reassignCubes();
						}
						else if (cubes[faceToRotate[0]].rotation.x >= 1.565 + Math.PI  && cubes[faceToRotate[0]].rotation.x <= 1.575 + Math.PI){
							cubes[faceToRotate[0]].rotation.x = Math.PI + (Math.PI/2);
							animating = false;
							reassignCubes();
						}
						else if (cubes[faceToRotate[0]].rotation.x >= Math.PI * 2)
						{
							for (i = 0; i < 9; i++)
							{
								cubes[faceToRotate[i]].rotation.x = 0;
							
							}
							animating = false;
							reassignCubes();
						}
					}
					else if(g_notation == "l")
					{
						for (i = 0; i < 9; i++)
						{
							cubes[faceToRotate[i]].rotation.x += 0.01
						}
						//Math.PI is too precise for direct comparison, so check a range around PI/2 or 90 degrees (1.570796)
						if (cubes[faceToRotate[0]].rotation.x >= 1.565 && cubes[faceToRotate[0]].rotation.x <= 1.575)
						{
							cubes[faceToRotate[0]].rotation.x = Math.PI /2;
							animating = false;
							reassignCubes();
						}
						//implementing dirty checks to prevent over rotation and current wworks with U
						else if (cubes[faceToRotate[0]].rotation.x >= 1.565 + Math.PI / 2 && cubes[faceToRotate[0]].rotation.x <= 1.575 + Math.PI/2){
							cubes[faceToRotate[0]].rotation.x = Math.PI;
							animating = false;
							reassignCubes();
						}
						else if (cubes[faceToRotate[0]].rotation.x >= 1.565 + Math.PI  && cubes[faceToRotate[0]].rotation.x <= 1.575 + Math.PI){
							cubes[faceToRotate[0]].rotation.x = Math.PI + (Math.PI/2);
							animating = false;
							reassignCubes();
						}
						else if (cubes[faceToRotate[0]].rotation.x >= Math.PI * 2)
						{
							for (i = 0; i < 9; i++)
							{
								cubes[faceToRotate[i]].rotation.x = 0;
							
							}
							animating = false;
							reassignCubes();
						}
					}
					
					
				}
				renderer.render(scene, camera);
			};
			
			var reassignCubes = function()
			{
				var cubesReferences = [];
				
				for (i = 0; i < 9; i++)
				{
					cubesReferences[i] = cubes[rotatedFace[i]];
				}
				for (i = 0; i < 9; i++)
				{
					cubes[faceToRotate[i]] = cubesReferences[i];
				}
			}
			
			var animateStep = function()
			{
				if(!animating)
				{
					animating = true;
					var algorithmOutput = document.getElementById("algorithm").value;
					switch (algorithmOutput)
					{
						case "R":
							faceToRotate = rightFace;
							rotatedFace = rightRotatedCC;
							g_notation = "r";
							break;
						case "L":
							faceToRotate = leftFace;
							rotatedFace = leftRotatedCC;
							g_notation = "l";
							break;
						case "U":
							faceToRotate = upFace;
							rotatedFace = upRotatedCC;
							g_notation = "u";
							break;
						case "D":
							faceToRotate = downFace;
							rotatedFace = downRotatedCC;
							g_notation = "d";
							break;
						case "F":
							faceToRotate = frontFace;
							rotatedFace = frontRotatedCC;
							g_notation = "f";
							break;
						case "B":
							faceToRotate = backFace;
							rotatedFace = backRotatedCC;
							g_notation = "b";
							break;
					}
				}
				document.getElementById("algorithmOutput").innerHTML = algorithmOutput;
			}	

			render();
		</script>
		<br></br>
		<input type="text" id="algorithm">
		<button onclick="animateStep()">Animate</button>
		<p id="algorithmOutput"></p>
	</body>
</html>